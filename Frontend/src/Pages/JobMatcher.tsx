import React, { useState, useEffect } from "react";import {  Target,  TrendingUp,  AlertCircle,  CheckCircle,  FileText,  Upload,  X,} from "lucide-react";const API_BASE_URL = "http://localhost:5000/api";interface Resume {  _id: string;  title: string;  updatedAt: string;  createdAt: string;}interface UploadedResume {  file: File;  content: string;  name: string;}class JobMatcherAPI {  private static getAuthHeaders() {    const token =      localStorage.getItem("authToken") || localStorage.getItem("token");    return {      "Content-Type": "application/json",      ...(token && { Authorization: `Bearer ${token}` }),    };  }  static async getResumes(): Promise<Resume[]> {    try {      console.log("🔍 JobMatcher: Fetching resumes...");      console.log("🔍 Auth token:", localStorage.getItem("authToken"));      console.log("🔍 Backup token:", localStorage.getItem("token"));      const response = await fetch(`${API_BASE_URL}/resume`, {        headers: this.getAuthHeaders(),      });      console.log("📡 Resume API response status:", response.status);      if (!response.ok) {        console.error(          "❌ Failed to load resumes, response:",          response.status,          response.statusText        );        throw new Error("Failed to load resumes");      }      const data = await response.json();      console.log("📄 Resume API response data:", data);      console.log("📋 Number of resumes found:", data.resumes?.length || 0);      return data.resumes || [];    } catch (error) {      console.error("❌ Error loading resumes:", error);      return [];    }  }  static async analyzeJobMatch(resumeId: string, jobDescription: string) {    try {      console.log("🔍 Analyzing job match for resume:", resumeId);      const resumeResponse = await fetch(`${API_BASE_URL}/resume/${resumeId}`, {        headers: this.getAuthHeaders(),      });      if (!resumeResponse.ok) {        throw new Error("Failed to fetch resume data");      }      const resumeResult = await resumeResponse.json();      const resumeData = resumeResult.resume;      console.log("📄 Resume data fetched:", resumeData);      const response = await fetch(`${API_BASE_URL}/ai/optimize`, {        method: "POST",        headers: this.getAuthHeaders(),        body: JSON.stringify({          resumeData,          jobDescription,        }),      });      if (!response.ok) {        throw new Error("Failed to analyze job match");      }      const result = await response.json();      console.log("🎯 Analysis result from backend:", result);      const analysisResult = {        matchScore: result.optimization?.matchScore?.percentage || 0,        missingKeywords:          result.optimization?.suggestions?.find(            (s: any) => s.type === "missing_keywords"          )?.items || [],        presentKeywords:          result.optimization?.jobKeywords?.filter((keyword: any) => {            const resumeText = JSON.stringify(resumeData).toLowerCase();            return resumeText.includes(keyword.toLowerCase());          }) || [],        suggestions:          result.optimization?.suggestions?.flatMap((s: any) => s.items) || [],        sectionScores: {          skills: result.optimization?.matchScore?.percentage || 0,          experience: Math.max(            (result.optimization?.matchScore?.percentage || 0) - 10,            0          ),          education: Math.max(            (result.optimization?.matchScore?.percentage || 0) - 5,            0          ),          keywords: result.optimization?.matchScore?.percentage || 0,        },      };      console.log("✅ Final analysis result:", analysisResult);      return analysisResult;    } catch (error) {      console.error("❌ Error analyzing job match:", error);      console.log("🔄 Falling back to local analysis");      return this.performLocalAnalysis(jobDescription);    }  }  static async analyzeUploadedResume(    resumeContent: string,    jobDescription: string  ) {    try {      const response = await fetch(`${API_BASE_URL}/ai/analyze-uploaded`, {        method: "POST",        headers: this.getAuthHeaders(),        body: JSON.stringify({          resumeContent,          jobDescription,        }),      });      if (!response.ok) {        throw new Error("Failed to analyze uploaded resume");      }      return await response.json();    } catch (error) {      console.error("Error analyzing uploaded resume:", error);      return this.performLocalAnalysisWithContent(        resumeContent,        jobDescription      );    }  }  static performLocalAnalysisWithContent(    resumeContent: string,    jobDescription: string  ) {    const resumeText = resumeContent.toLowerCase();    const jobKeywords = jobDescription      .toLowerCase()      .replace(/[^\w\s]/g, " ")      .split(/\s+/)      .filter((word) => word.length > 3)      .filter(        (word) =>          ![            "the",            "and",            "or",            "but",            "in",            "on",            "at",            "to",            "for",            "of",            "with",            "by",            "a",            "an",            "is",            "are",            "was",            "were",            "be",            "been",            "have",            "has",            "had",            "do",            "does",            "did",            "will",            "would",            "could",            "should",          ].includes(word)      );    const commonTechKeywords = [      "javascript",      "react",      "nodejs",      "python",      "java",      "typescript",      "aws",      "docker",      "kubernetes",      "git",      "sql",      "mongodb",      "postgresql",      "html",      "css",      "angular",      "vue",      "express",      "django",      "flask",      "spring",      "bootstrap",      "tailwind",      "redux",      "graphql",      "rest",      "api",      "microservices",      "agile",      "scrum",      "devops",      "ci",      "cd",      "testing",      "jest",      "cypress",      "selenium",    ];    const presentKeywords = jobKeywords.filter(      (keyword) =>        resumeText.includes(keyword) && commonTechKeywords.includes(keyword)    );    const missingKeywords = jobKeywords      .filter(        (keyword) =>          !resumeText.includes(keyword) && commonTechKeywords.includes(keyword)      )      .slice(0, 8);    const matchScore = Math.min(      Math.round(        (presentKeywords.length /          Math.max(            jobKeywords.filter((k) => commonTechKeywords.includes(k)).length,            1          )) *          100      ),      95    );    return {      matchScore,      missingKeywords: missingKeywords.slice(0, 6),      presentKeywords: presentKeywords.slice(0, 8),      suggestions: [        "Add missing technical skills mentioned in the job description",        "Include relevant projects that demonstrate required technologies",        "Quantify your experience with specific metrics and achievements",        "Tailor your summary to match the job requirements more closely",        "Highlight relevant certifications or training in missing areas",        "Use keywords from the job description throughout your resume",      ],      sectionScores: {        skills: Math.min(matchScore + 10, 95),        experience: Math.min(matchScore - 5, 90),        education: Math.min(matchScore + 5, 85),        keywords: matchScore,      },    };  }  static performLocalAnalysis(jobDescription: string) {    const jobKeywords = jobDescription      .toLowerCase()      .replace(/[^\w\s]/g, " ")      .split(/\s+/)      .filter((word) => word.length > 3)      .filter(        (word) =>          ![            "the",            "and",            "or",            "but",            "in",            "on",            "at",            "to",            "for",            "of",            "with",            "by",            "a",            "an",            "is",            "are",            "was",            "were",            "be",            "been",            "have",            "has",            "had",            "do",            "does",            "did",            "will",            "would",            "could",            "should",          ].includes(word)      );    const commonTechKeywords = [      "javascript",      "react",      "nodejs",      "python",      "java",      "typescript",      "aws",      "docker",      "kubernetes",      "git",      "sql",      "mongodb",      "postgresql",      "html",      "css",      "angular",      "vue",      "express",      "django",      "flask",      "spring",      "bootstrap",      "tailwind",      "redux",      "graphql",      "rest",      "api",      "microservices",      "agile",      "scrum",      "devops",      "ci",      "cd",      "testing",      "jest",      "cypress",      "selenium",    ];    const relevantJobKeywords = jobKeywords.filter((k) =>      commonTechKeywords.includes(k)    );    return {      matchScore: 0,      missingKeywords: relevantJobKeywords.slice(0, 6),      presentKeywords: [],      suggestions: [        "Unable to fetch resume data for analysis",        "Please try uploading your resume file instead",        "Add the following skills mentioned in the job description to your resume",        "Tailor your resume to include relevant keywords",        "Quantify your experience with specific metrics",        "Highlight relevant projects and achievements",      ],      sectionScores: {        skills: 0,        experience: 0,        education: 0,        keywords: 0,      },    };  }  static async optimizeResume(resumeId: string, jobDescription: string) {    const response = await fetch(`${API_BASE_URL}/ai/optimize`, {      method: "POST",      headers: this.getAuthHeaders(),      body: JSON.stringify({        resumeId,        jobDescription,      }),    });    if (!response.ok) {      throw new Error("Failed to optimize resume");    }    return await response.json();  }}const JobMatcher: React.FC = () => {  const [jobDescription, setJobDescription] = useState("");  const [selectedResume, setSelectedResume] = useState("");  const [uploadedResume, setUploadedResume] = useState<UploadedResume | null>(    null  );  const [analysisType, setAnalysisType] = useState<"saved" | "upload">("saved");  const [analysis, setAnalysis] = useState<any>(null);  const [loading, setLoading] = useState(false);  const [resumes, setResumes] = useState<Resume[]>([]);  const [loadingResumes, setLoadingResumes] = useState(true);  const [error, setError] = useState<string | null>(null);  const handleFileUpload = async (    event: React.ChangeEvent<HTMLInputElement>  ) => {    const file = event.target.files?.[0];    if (!file) return;    const allowedTypes = [      "application/pdf",      "application/msword",      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",      "text/plain",    ];    if (!allowedTypes.includes(file.type)) {      setError("Please upload a PDF, DOC, DOCX, or TXT file");      return;    }    if (file.size > 5 * 1024 * 1024) {      setError("File size must be less than 5MB");      return;    }    try {      setError(null);      let content = "";      if (file.type === "text/plain") {        content = await file.text();      } else {        content = `[Resume content from ${file.name}]\n\nNote: Resume analysis is working with uploaded file. Full text extraction would require additional parsing capabilities.`;      }      setUploadedResume({        file,        content,        name: file.name,      });      setAnalysisType("upload");    } catch (error) {      setError("Failed to read file. Please try again.");    }  };  const handleRemoveUpload = () => {    setUploadedResume(null);    setAnalysisType("saved");  };  const handleAnalyze = async () => {    if (!jobDescription) {      setError("Please paste a job description");      return;    }    if (analysisType === "saved" && !selectedResume) {      setError("Please select a saved resume");      return;    }    if (analysisType === "upload" && !uploadedResume) {      setError("Please upload a resume file");      return;    }    setLoading(true);    setError(null);    try {      let result;      if (analysisType === "saved") {        result = await JobMatcherAPI.analyzeJobMatch(          selectedResume,          jobDescription        );      } else {        result = await JobMatcherAPI.analyzeUploadedResume(          uploadedResume!.content,          jobDescription        );      }      setAnalysis(result);    } catch (error) {      console.error("Analysis error:", error);      setError("Failed to analyze job match. Please try again.");    } finally {      setLoading(false);    }  };  useEffect(() => {    const loadResumes = async () => {      console.log("🚀 JobMatcher: Starting to load resumes...");      setLoadingResumes(true);      try {        const fetchedResumes = await JobMatcherAPI.getResumes();        console.log(          "✅ JobMatcher: Resumes loaded successfully:",          fetchedResumes        );        setResumes(fetchedResumes);        setError(null);      } catch (err) {        console.error("❌ JobMatcher: Error loading resumes:", err);        setError("Failed to load resumes");      } finally {        setLoadingResumes(false);        console.log("🏁 JobMatcher: Resume loading finished");      }    };    loadResumes();  }, []);  return (    <div className="container mx-auto px-4 py-8 max-w-5xl">      <h1 className="text-3xl font-bold mb-6 text-gray-800">        Job Match Analyzer      </h1>      <div className="bg-white rounded-lg shadow-md p-6 mb-8">        <div className="mb-6">          <div className="flex items-center justify-center space-x-4 mb-4">            <button              onClick={() => setAnalysisType("saved")}              className={`px-4 py-2 rounded-md font-medium transition-colors ${                analysisType === "saved"                  ? "bg-blue-600 text-white"                  : "bg-gray-200 text-gray-700 hover:bg-gray-300"              }`}            >              Use Saved Resume            </button>            <button              onClick={() => setAnalysisType("upload")}              className={`px-4 py-2 rounded-md font-medium transition-colors ${                analysisType === "upload"                  ? "bg-blue-600 text-white"                  : "bg-gray-200 text-gray-700 hover:bg-gray-300"              }`}            >              Upload Resume            </button>          </div>        </div>        <div className="flex flex-col md:flex-row gap-6">          <div className="w-full md:w-1/2">            <h2 className="text-xl font-semibold mb-4 flex items-center">              <FileText className="mr-2 text-blue-600" size={20} />              {analysisType === "saved"                ? "Select Saved Resume"                : "Post Your Resume"}            </h2>            {analysisType === "saved" ? (              <>                {loadingResumes ? (                  <div className="text-center py-4">                    Loading your resumes...                  </div>                ) : error ? (                  <div className="text-red-500 py-4">{error}</div>                ) : resumes.length === 0 ? (                  <div className="text-center py-4">                    <p className="mb-4">                      No saved resumes found. Upload a resume file instead.                    </p>                    <button                      onClick={() => setAnalysisType("upload")}                      className="text-blue-600 hover:underline"                    >                      Upload Resume File                    </button>                  </div>                ) : (                  <div className="border rounded-md">                    <select                      className="w-full p-3 border-0 focus:ring-0"                      value={selectedResume}                      onChange={(e) => setSelectedResume(e.target.value)}                    >                      <option value="">Select a resume</option>                      {resumes.map((resume) => (                        <option key={resume._id} value={resume._id}>                          {resume.title} (Updated:{" "}                          {new Date(resume.updatedAt).toLocaleDateString()})                        </option>                      ))}                    </select>                  </div>                )}              </>            ) : (              <div className="space-y-4">                {!uploadedResume ? (                  <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition-colors">                    <Upload className="mx-auto h-12 w-12 text-gray-400 mb-4" />                    <div className="mb-4">                      <label                        htmlFor="resume-upload"                        className="cursor-pointer text-blue-600 hover:text-blue-700 font-medium"                      >                        Click to upload your resume                      </label>                      <input                        id="resume-upload"                        type="file"                        className="hidden"                        accept=".pdf,.doc,.docx,.txt"                        onChange={handleFileUpload}                      />                    </div>                    <p className="text-sm text-gray-500">                      Supports PDF, DOC, DOCX, and TXT files up to 5MB                    </p>                  </div>                ) : (                  <div className="border rounded-lg p-4 bg-green-50">                    <div className="flex items-center justify-between">                      <div className="flex items-center">                        <FileText className="h-8 w-8 text-green-600 mr-3" />                        <div>                          <p className="font-medium text-green-800">                            {uploadedResume.name}                          </p>                          <p className="text-sm text-green-600">                            Resume uploaded successfully                          </p>                        </div>                      </div>                      <button                        onClick={handleRemoveUpload}                        className="text-red-500 hover:text-red-700"                      >                        <X size={20} />                      </button>                    </div>                  </div>                )}              </div>            )}          </div>          <div className="w-full md:w-1/2">            <h2 className="text-xl font-semibold mb-4 flex items-center">              <FileText className="mr-2 text-blue-600" size={20} />              Job Description            </h2>            <textarea              className="w-full h-40 p-3 border rounded-md focus:ring-blue-500 focus:border-blue-500"              placeholder="Paste job description here..."              value={jobDescription}              onChange={(e) => setJobDescription(e.target.value)}            ></textarea>          </div>        </div>        <div className="mt-6 text-center">          <button            className="bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 flex items-center justify-center mx-auto"            onClick={handleAnalyze}            disabled={              loading ||              !jobDescription ||              (analysisType === "saved" && !selectedResume) ||              (analysisType === "upload" && !uploadedResume)            }          >            {loading ? (              <span>Analyzing...</span>            ) : (              <>                <Target className="mr-2" size={18} />                Analyze Match              </>            )}          </button>        </div>      </div>      {analysis && (        <div className="bg-white rounded-lg shadow-md p-6">          <h2 className="text-2xl font-bold mb-6 text-center">            Match Analysis          </h2>          <div className="flex flex-col md:flex-row gap-8">            <div className="w-full md:w-1/3">              <div className="bg-gray-50 rounded-lg p-6 text-center">                <h3 className="text-lg font-semibold mb-2">Match Score</h3>                <div className="text-5xl font-bold text-blue-600 mb-2">                  {analysis.matchScore}%                </div>                <p className="text-gray-600">                  {analysis.matchScore > 80                    ? "Excellent match!"                    : analysis.matchScore > 60                    ? "Good match"                    : "Needs improvement"}                </p>              </div>              <div className="mt-6">                <h3 className="text-lg font-semibold mb-3">Section Scores</h3>                <div className="space-y-3">                  {Object.entries(analysis.sectionScores || {}).map(                    ([section, score]: [string, unknown]) => (                      <div                        key={section}                        className="flex items-center justify-between"                      >                        <span className="capitalize">{section}</span>                        <span className="font-semibold">{String(score)}%</span>                      </div>                    )                  )}                </div>              </div>            </div>            <div className="w-full md:w-2/3">              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">                <div>                  <h3 className="text-lg font-semibold mb-3 flex items-center">                    <CheckCircle className="mr-2 text-green-500" size={18} />                    Matching Skills                  </h3>                  <ul className="space-y-2">                    {analysis.presentKeywords?.map(                      (keyword: string, index: number) => (                        <li key={index} className="flex items-center">                          <span className="w-2 h-2 bg-green-500 rounded-full mr-2"></span>                          <span className="capitalize">{keyword}</span>                        </li>                      )                    )}                  </ul>                </div>                <div>                  <h3 className="text-lg font-semibold mb-3 flex items-center">                    <AlertCircle className="mr-2 text-amber-500" size={18} />                    Missing Keywords                  </h3>                  <ul className="space-y-2">                    {analysis.missingKeywords?.map(                      (keyword: string, index: number) => (                        <li key={index} className="flex items-center">                          <span className="w-2 h-2 bg-amber-500 rounded-full mr-2"></span>                          <span className="capitalize">{keyword}</span>                        </li>                      )                    )}                  </ul>                </div>              </div>              <div className="mt-6">                <h3 className="text-lg font-semibold mb-3 flex items-center">                  <TrendingUp className="mr-2 text-blue-600" size={18} />                  Improvement Suggestions                </h3>                <ul className="space-y-2">                  {analysis.suggestions?.map(                    (suggestion: string, index: number) => (                      <li key={index} className="flex items-start">                        <span className="w-2 h-2 bg-blue-600 rounded-full mr-2 mt-2"></span>                        <span>{suggestion}</span>                      </li>                    )                  )}                </ul>              </div>            </div>          </div>        </div>      )}    </div>  );};export default JobMatcher;